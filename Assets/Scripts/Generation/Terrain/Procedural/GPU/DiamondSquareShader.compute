#pragma kernel CSMain

RWStructuredBuffer<float> heightmap;

uint width;
float height;
float squareSize;
uint externalSeed;

uint wang_hash(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

// normalizes the given value between -1 and 1
float normalize(uint x)
{
	return 2 * (x / 4294967295.0) - 1;		// equivalent to -> f(x) = 2 * ((x - min) / (max - min)) - 1
}

float random(uint range)
{
	return normalize(wang_hash(externalSeed + range));
}

bool isInsideLimits(uint3 id)
{
	return id.x > 1 && id.x < width-1 && 
		id.y > 1 && id.y < width-1;
}

float getHeight(uint2 position)
{
	return heightmap[position.x + position.y];
}

float getHeightIfValid(uint position, uint3 id)
{
	return isInsideLimits(id) ? heightmap[position] : 0;
}

float average(float a, float b, float c, float d)
{
	return (d == 0) ? (a + b + c) / 3.0 : (a + b + c + d) * 0.25;
}

void DiamondSquareAlgorithm(uint size, uint3 id)
{
	uint col = id.x * squareSize;
	uint row = id.y * squareSize;

	uint halfSize = size / 2;

	uint mid = (row+halfSize)*(width+1) + (col + halfSize);
	uint topLeft = row*(width+1) + col;
	uint topRight = row*(width+1) + (col + size);
	uint bottomLeft = (row+size)*(width+1) + col;
	uint bottomRight = (row+size)*(width+1) + (col + size);

	// diamond step
	heightmap[mid] = average(heightmap[topLeft], heightmap[topRight], heightmap[bottomLeft], heightmap[bottomRight]) + random(mid) * height;

	uint up = topLeft + halfSize;
	uint down = bottomLeft + halfSize;
	uint left = mid - halfSize;
	uint right = mid + halfSize;

	// square step
	heightmap[up] = average(heightmap[topLeft], heightmap[topRight], heightmap[mid], getHeightIfValid(up + halfSize, id)) + random(up) * height;
	heightmap[down] = average(heightmap[bottomLeft], heightmap[bottomRight], heightmap[mid], getHeightIfValid(down - halfSize, id)) + random(down) * height;
	heightmap[left] = average(heightmap[topLeft], heightmap[bottomLeft], heightmap[mid], getHeightIfValid(left - halfSize, id)) + random(left) * height;
	heightmap[right] = average(heightmap[topRight], heightmap[bottomRight], heightmap[mid], getHeightIfValid(right + halfSize, id)) + random(right) * height;
}

[numthreads(1, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	DiamondSquareAlgorithm(squareSize, id);
}
