#pragma kernel CSMain

RWStructuredBuffer<float> terrain;

uint width;
float height;
float squareSize;
uint externalSeed;

uint wang_hash(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

// normalizes the given value between -1 and 1
float normalize(uint x)
{
	return 2 * (x / 4294967295.0) - 1;		// equivalent to -> f(x) = 2 * ((x - min) / (max - min)) - 1
}

float random(uint seed, uint offset)
{
	float normalizedRandom = normalize(wang_hash(seed+offset));
	return normalizedRandom;
}

void DiamondSquareAlgorithm(uint row, uint col, uint size, uint seed)
{
	uint halfSize = (uint)(size*0.5);
	uint mid = (row+halfSize)*(width+1) + (col+halfSize);
	uint topLeft = row * (width+1)+col;
	uint bottomLeft = (row+size)*(width+1)+col;

	// diamond step
	terrain[mid] = (terrain[topLeft]+terrain[topLeft+size]+terrain[bottomLeft]+terrain[bottomLeft+size]) * 0.25 + random(seed, mid) * height;

	// square step
	terrain[topLeft+halfSize] = (terrain[topLeft]+terrain[topLeft+size]+terrain[mid]) / 3 + random(seed, topLeft+halfSize) * height;
	terrain[mid-halfSize] = (terrain[topLeft]+terrain[bottomLeft]+terrain[mid]) / 3 + random(seed, mid-halfSize) * height;
	terrain[mid+halfSize] = (terrain[topLeft+size]+terrain[bottomLeft+size]+terrain[mid]) / 3 + random(seed, mid+halfSize) * height;
	terrain[bottomLeft+halfSize] = (terrain[bottomLeft]+terrain[bottomLeft+size]+terrain[mid]) / 3 + random(seed, bottomLeft+halfSize) * height;
}

[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	uint col = (id.x) * squareSize;
	uint row = (id.y) * squareSize;
	
	uint seed = id.xy + externalSeed;

	DiamondSquareAlgorithm(row, col, squareSize, seed);
}
